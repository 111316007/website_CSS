<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>貪吃蛇大作戰 (Slither Style)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* 遊戲專用：禁止捲動 */
            background-color: #1a1a1a;
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            touch-action: none;
        }

        canvas { display: block; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        }

        #score-board {
            padding: 20px; color: white; font-size: 20px; font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #player-id { font-size: 24px; color: #7bed9f; margin-bottom: 5px; }

        #minimap-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 150px; height: 150px; background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 50%; overflow: hidden;
        }

        #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7); display: flex; flex-direction: column;
            align-items: center; justify-content: center; pointer-events: auto;
            visibility: hidden; opacity: 0; transition: opacity 0.3s; z-index: 10;
        }

        #game-over-screen.active { visibility: visible; opacity: 1; }

        h1 { color: #ff4757; font-size: 50px; margin: 0 0 20px 0; text-shadow: 0 0 10px #ff4757; }
        .final-score { color: white; font-size: 24px; margin-bottom: 30px; }

        button {
            background: #2ed573; color: white; border: none; padding: 15px 40px;
            font-size: 24px; border-radius: 30px; cursor: pointer;
            box-shadow: 0 5px 15px rgba(46, 213, 115, 0.4); transition: transform 0.1s;
        }
        button:hover { transform: scale(1.05); background: #26af61; }
        button:active { transform: scale(0.95); }
        
        #leaderboard {
            position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.5);
            color: white; padding: 10px; border-radius: 8px; min-width: 150px;
        }
        #leaderboard h3 { margin: 0 0 10px 0; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.3); padding-bottom: 5px; }
        .leader-item { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 14px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div id="score-board">
            <div id="player-id">ID: 鄭聿宸</div>
            <div>長度: <span id="length-display">10</span></div>
        </div>
        <div id="leaderboard">
            <h3>排行榜</h3>
            <div id="leader-list"></div>
        </div>
        <div id="minimap-container">
            <canvas id="minimap" width="150" height="150"></canvas>
        </div>
    </div>
    <div id="game-over-screen">
        <h1>遊戲結束</h1>
        <div class="final-score">最終長度: <span id="final-score">0</span></div>
        <button id="restart-btn">再次挑戰</button>
    </div>

    <script>
        (function() {
            const CONFIG = {
                worldSize: 6000, baseSpeed: 3, boostSpeed: 8, boostLoss: 0.05,
                minBoostLength: 15, turnSpeed: 0.08, foodCount: 1200, aiCount: 50,
                snakeWidth: 20, segmentSpacing: 8,
                colors: ['#ff4757', '#2ed573', '#1e90ff', '#ffa502', '#7bed9f', '#70a1ff', '#5352ed', '#ff6b81']
            };
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const miniCanvas = document.getElementById('minimap');
            const miniCtx = miniCanvas.getContext('2d');
            let width, height, animationId;
            const random = (min, max) => Math.random() * (max - min) + min;
            const randomColor = () => CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
            const getDistance = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
            let snakes = [], foods = [], particles = [], player, camera = { x: 0, y: 0 }, mouse = { x: 0, y: 0 }, mouseDown = false, isGameOver = false;

            class Food {
                constructor(x, y, value = 1, color = null) {
                    this.x = x || random(-CONFIG.worldSize/2, CONFIG.worldSize/2);
                    this.y = y || random(-CONFIG.worldSize/2, CONFIG.worldSize/2);
                    this.value = value; this.radius = 4 + (value * 0.5);
                    this.color = color || randomColor(); this.floatOffset = random(0, Math.PI * 2);
                }
                draw(ctx, time) {
                    const scale = 1 + Math.sin(time * 0.005 + this.floatOffset) * 0.1;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * scale, 0, Math.PI * 2);
                    ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                    ctx.fill(); ctx.shadowBlur = 0; ctx.closePath();
                }
            }

            class Particle {
                constructor(x, y, color) {
                    this.x = x; this.y = y; this.color = color;
                    const angle = random(0, Math.PI * 2); const speed = random(1, 4);
                    this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
                    this.life = 1.0; this.decay = random(0.01, 0.03);
                }
                update() { this.x += this.vx; this.y += this.vy; this.life -= this.decay; }
                draw(ctx) {
                    ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.beginPath();
                    ctx.arc(this.x, this.y, 3, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1;
                }
            }

            class Snake {
                constructor(x, y, isBot = true, name = "Bot") {
                    this.x = x; this.y = y; this.angle = random(0, Math.PI * 2); this.targetAngle = this.angle;
                    this.speed = CONFIG.baseSpeed; this.name = name; this.isBot = isBot;
                    this.color = randomColor(); this.headColor = '#ffffff'; this.radius = CONFIG.snakeWidth / 2;
                    this.dead = false; this.path = []; this.length = 10; this.score = 0;
                    for (let i = 0; i < this.length * CONFIG.segmentSpacing; i++) this.path.push({ x: x, y: y });
                    this.aiChangeDirTimer = 0; this.boosting = false;
                }
                update() {
                    if (this.dead) return;
                    if (this.isBot) { this.updateAI(); } else {
                        this.boosting = mouseDown && this.length > CONFIG.minBoostLength;
                        this.targetAngle = Math.atan2(mouse.y, mouse.x);
                    }
                    let currentSpeed = this.speed;
                    if (this.boosting) {
                        currentSpeed = CONFIG.boostSpeed; this.length -= CONFIG.boostLoss; this.score -= CONFIG.boostLoss * 10;
                        if (this.length <= CONFIG.minBoostLength) { this.boosting = false; currentSpeed = this.speed; }
                        if (Math.random() < 0.2 && this.path.length > 0) {
                            const tail = this.path[this.path.length - 1];
                            foods.push(new Food(tail.x + random(-5, 5), tail.y + random(-5, 5), 0.6, this.color));
                        }
                    }
                    let diff = this.targetAngle - this.angle;
                    while (diff < -Math.PI) diff += Math.PI * 2; while (diff > Math.PI) diff -= Math.PI * 2;
                    if (Math.abs(diff) < CONFIG.turnSpeed) this.angle = this.targetAngle;
                    else this.angle += Math.sign(diff) * CONFIG.turnSpeed;
                    this.x += Math.cos(this.angle) * currentSpeed; this.y += Math.sin(this.angle) * currentSpeed;
                    this.path.unshift({ x: this.x, y: this.y });
                    const requiredPathLength = this.length * CONFIG.segmentSpacing + 10;
                    while (this.path.length > requiredPathLength) this.path.pop();
                    const limit = CONFIG.worldSize / 2;
                    if (this.x < -limit || this.x > limit || this.y < -limit || this.y > limit) this.die();
                }
                updateAI() {
                    this.aiChangeDirTimer--;
                    if (this.length > CONFIG.minBoostLength && Math.random() < 0.01) this.boosting = !this.boosting;
                    if (this.length <= CONFIG.minBoostLength) this.boosting = false;
                    const limit = CONFIG.worldSize / 2 - 100;
                    if (this.x < -limit || this.x > limit || this.y < -limit || this.y > limit) {
                        this.targetAngle = Math.atan2(0 - this.y, 0 - this.x); return;
                    }
                    if (this.aiChangeDirTimer <= 0) {
                        let nearestFood = null, minDist = 300;
                        for (let f of foods) {
                            const d = getDistance(this.x, this.y, f.x, f.y);
                            if (d < minDist) { minDist = d; nearestFood = f; }
                        }
                        if (nearestFood) this.targetAngle = Math.atan2(nearestFood.y - this.y, nearestFood.x - this.x);
                        else this.targetAngle += random(-1, 1);
                        this.aiChangeDirTimer = random(10, 50);
                    }
                }
                draw(ctx) {
                    if (this.dead) return;
                    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                    ctx.shadowBlur = this.boosting ? 20 : 10; ctx.shadowColor = this.color;
                    const drawLength = Math.floor(this.length);
                    for (let i = drawLength - 1; i >= 0; i--) {
                        const index = i * CONFIG.segmentSpacing;
                        if (index >= this.path.length) continue;
                        const point = this.path[index];
                        ctx.fillStyle = this.color; ctx.beginPath();
                        let radius = this.radius + Math.min(5, this.score / 100);
                        if (i === drawLength - 1) radius *= 0.8;
                        ctx.arc(point.x, point.y, radius, 0, Math.PI * 2); ctx.fill();
                    }
                    const headX = this.x, headY = this.y;
                    let headRadius = this.radius + Math.min(5, this.score / 100);
                    const eyeOffset = headRadius * 0.6, eyeSize = headRadius * 0.35;
                    ctx.fillStyle = 'white'; ctx.shadowBlur = 0;
                    ctx.beginPath(); ctx.arc(headX + Math.cos(this.angle - 0.8) * eyeOffset, headY + Math.sin(this.angle - 0.8) * eyeOffset, eyeSize, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(headX + Math.cos(this.angle + 0.8) * eyeOffset, headY + Math.sin(this.angle + 0.8) * eyeOffset, eyeSize, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
                    ctx.fillText(this.name, headX, headY - headRadius - 10);
                }
                grow(value) {
                    this.length += value; this.score += value * 10;
                    const currentTail = this.path[this.path.length - 1];
                    for(let i=0; i<value * CONFIG.segmentSpacing; i++) this.path.push({...currentTail});
                }
                die() {
                    this.dead = true;
                    for (let i = 0; i < this.length; i += 2) {
                        const index = i * CONFIG.segmentSpacing;
                        if (index < this.path.length) {
                            const p = this.path[index];
                            foods.push(new Food(p.x + random(-10, 10), p.y + random(-10, 10), 2, this.color));
                        }
                    }
                    for(let i=0; i<15; i++) particles.push(new Particle(this.x, this.y, this.color));
                    if (!this.isBot) gameOver(); else setTimeout(() => spawnBot(), 2000);
                }
            }

            function resize() { width = window.innerWidth; height = window.innerHeight; canvas.width = width; canvas.height = height; }
            function spawnBot() {
                const names = ["小黑", "阿呆", "貪吃鬼", "SnakePro", "Noob", "Speedy", "大蟒蛇", "Twist", "Python", "Cobra"];
                const name = names[Math.floor(Math.random() * names.length)] + Math.floor(random(1, 99));
                const bot = new Snake(random(-CONFIG.worldSize/2, CONFIG.worldSize/2), random(-CONFIG.worldSize/2, CONFIG.worldSize/2), true, name);
                bot.grow(Math.floor(random(0, 5))); snakes.push(bot);
            }
            function initGame() {
                snakes = []; foods = []; particles = []; isGameOver = false;
                document.getElementById('game-over-screen').classList.remove('active');
                player = new Snake(0, 0, false, "你"); snakes.push(player);
                for (let i = 0; i < CONFIG.aiCount; i++) spawnBot();
                for (let i = 0; i < CONFIG.foodCount; i++) foods.push(new Food());
            }
            function update() {
                if (foods.length < CONFIG.foodCount && Math.random() < 0.1) foods.push(new Food());
                snakes.forEach(snake => snake.update());
                for (let s of snakes) {
                    if (s.dead) continue;
                    for (let i = foods.length - 1; i >= 0; i--) {
                        if (getDistance(s.x, s.y, foods[i].x, foods[i].y) < (s.radius + Math.min(5, s.score/100)) + foods[i].radius) {
                            s.grow(foods[i].value); foods.splice(i, 1);
                        }
                    }
                }
                for (let i = 0; i < snakes.length; i++) {
                    let s1 = snakes[i]; if (s1.dead) continue;
                    for (let j = 0; j < snakes.length; j++) {
                        let s2 = snakes[j]; if (s1 === s2 || s2.dead) continue;
                        if (getDistance(s1.x, s1.y, s2.x, s2.y) > (s2.length * CONFIG.segmentSpacing + 100)) continue;
                        for (let k = 0; k < s2.path.length; k += CONFIG.segmentSpacing) {
                            if (getDistance(s1.x, s1.y, s2.path[k].x, s2.path[k].y) < s1.radius + Math.min(5, s1.score/100) + (s2.radius + Math.min(5, s2.score/100) * (k === s2.path.length-1 ? 0.8 : 1)) - 2) {
                                s1.die(); break;
                            }
                        }
                        if (s1.dead) break;
                    }
                }
                for(let i = particles.length -1; i>=0; i--) { particles[i].update(); if(particles[i].life <= 0) particles.splice(i, 1); }
                if (!player.dead) { camera.x = width / 2 - player.x; camera.y = height / 2 - player.y; }
                document.getElementById('length-display').innerText = Math.floor(player.length);
            }
            function drawGrid(ctx) {
                const gridSize = 50, offsetX = camera.x % gridSize, offsetY = camera.y % gridSize;
                ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.beginPath();
                for (let x = offsetX; x < width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
                for (let y = offsetY; y < height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
                ctx.stroke();
                ctx.strokeStyle = '#ff4757'; ctx.lineWidth = 5;
                ctx.strokeRect(-CONFIG.worldSize/2 + camera.x, -CONFIG.worldSize/2 + camera.y, CONFIG.worldSize, CONFIG.worldSize);
            }
            function render() {
                ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0, 0, width, height);
                drawGrid(ctx); ctx.save(); ctx.translate(camera.x, camera.y);
                const time = Date.now();
                foods.forEach(f => { if (f.x + camera.x > -50 && f.x + camera.x < width + 50 && f.y + camera.y > -50 && f.y + camera.y < height + 50) f.draw(ctx, time); });
                particles.forEach(p => p.draw(ctx));
                snakes.forEach(s => { if (s !== player) s.draw(ctx); });
                if (!player.dead) player.draw(ctx);
                ctx.restore(); renderMinimap(); renderLeaderboard();
            }
            function renderMinimap() {
                miniCtx.clearRect(0, 0, 150, 150); const scale = 150 / CONFIG.worldSize;
                miniCtx.save(); miniCtx.translate(75, 75);
                snakes.forEach(s => { if (s.dead) return; miniCtx.fillStyle = s === player ? '#fff' : s.color; miniCtx.beginPath(); miniCtx.arc(s.x * scale, s.y * scale, s === player ? 3 : 2, 0, Math.PI * 2); miniCtx.fill(); });
                miniCtx.restore();
            }
            function renderLeaderboard() {
                const sorted = [...snakes].sort((a, b) => b.length - a.length).slice(0, 5);
                let html = '';
                sorted.forEach((s, index) => {
                    html += `<div class="leader-item" style="color:${s === player ? '#2ed573' : 'white'}"><span>#${index + 1} ${s.name}${s === player ? ' (你)' : ''}</span><span>${Math.floor(s.length)}</span></div>`;
                });
                document.getElementById('leader-list').innerHTML = html;
            }
            function gameOver() { isGameOver = true; document.getElementById('final-score').innerText = Math.floor(player.length); document.getElementById('game-over-screen').classList.add('active'); }
            function loop() { if (!isGameOver) update(); render(); animationId = requestAnimationFrame(loop); }
            window.addEventListener('resize', resize);
            window.addEventListener('mousemove', e => { mouse.x = e.clientX - width / 2; mouse.y = e.clientY - height / 2; });
            window.addEventListener('mousedown', () => mouseDown = true); window.addEventListener('mouseup', () => mouseDown = false);
            window.addEventListener('touchmove', e => { e.preventDefault(); const touch = e.touches[0]; mouse.x = touch.clientX - width / 2; mouse.y = touch.clientY - height / 2; }, { passive: false });
            window.addEventListener('touchstart', (e) => { mouseDown = true; const touch = e.touches[0]; mouse.x = touch.clientX - width / 2; mouse.y = touch.clientY - height / 2; }, { passive: false });
            window.addEventListener('touchend', () => mouseDown = false);
            document.getElementById('restart-btn').addEventListener('click', () => initGame());
            resize(); initGame(); loop();
        })();
    </script>
</body>
</html>